<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Trainer</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            align-items: flex-start; 
            min-height: 100vh;
            background-color: #282c34;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; 
        }

        .main-game-area {
            flex: 3; /* Takes up 3/4 of the space for game + history */
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between game container and history log */
            max-width: 900px; /* Applied here for when strategy guide is side-by-side */
        }

        .game-container {
            background-color: #1a1e24;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            text-align: center;
            width: 100%; /* Takes full width of its parent (.main-game-area) */
            box-sizing: border-box;
        }

        h1 {
            color: #61dafb;
            margin-bottom: 25px;
            font-size: 2.5em;
        }

        .game-area {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            gap: 20px;
        }

        .player-area, .dealer-area {
            background-color: #3a3f4a;
            border-radius: 10px;
            padding: 20px;
            flex: 1;
            min-height: 200px;
            position: relative;
        }

        h2 {
            color: #a8a8a8;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            min-height: 80px; 
        }

        .card {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .card.hidden {
            background-color: #888;
            color: #888;
            border: 1px solid #555;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="100" viewBox="0 0 70 100"><rect x="0" y="0" width="70" height="100" fill="%23888"/><line x1="0" y1="0" x2="70" y2="100" stroke="%23555" stroke-width="2"/><line x1="70" y1="0" x2="0" y2="100" stroke="%23555" stroke-width="2"/><circle cx="35" cy="50" r="15" fill="%23666"/></svg>');
            background-size: cover;
        }

        .card .rank {
            font-size: 1.5em;
            line-height: 1;
        }

        .card .suit {
            font-size: 1em;
            line-height: 1;
        }

        .card.red {
            color: red;
        }

        .score {
            font-size: 1.8em;
            font-weight: bold;
            color: #61dafb;
        }

        .actions {
            margin-top: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }

        .action-button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .action-button:hover:not(:disabled) {
            background-color: #21a1f1;
            transform: translateY(-2px);
        }

        .action-button:disabled {
            background-color: #555;
            color: #aaa;
            cursor: not-allowed;
            box-shadow: none;
        }

        .new-game-button {
            background-color: #4CAF50;
        }

        .new-game-button:hover:not(:disabled) {
            background-color: #45a049;
        }

        .message {
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            min-height: 30px;
            color: #fdd835; 
        }

        .message.error {
            color: #ef5350; 
        }

        /* History Log Container */
        #history-log-container {
            background-color: #1a1e24; /* Match game-container */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            padding: 20px;
            color: #e0e0e0;
            font-size: 0.9em;
            text-align: left;
            width: 100%; /* Takes full width of its parent (.main-game-area) */
            box-sizing: border-box;
            max-height: 400px; /* Max height for the history log */
            overflow-y: auto; /* Scroll if content exceeds max-height */
        }

        #history-log-container h2 {
            text-align: center;
            color: #61dafb;
            margin-bottom: 15px;
        }

        #history-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        #history-table th, #history-table td {
            border: 1px solid #444;
            padding: 8px 6px;
            text-align: center;
            font-size: 0.85em;
        }

        #history-table th {
            background-color: #333;
            color: #61dafb;
            font-size: 0.9em;
        }

        #history-table tr:nth-child(even) {
            background-color: #222;
        }
        #history-table td.action-correct { color: #81C784; } /* Light Green */
        #history-table td.action-mistake { color: #FFB74D; } /* Light Orange */


        #session-stats {
            margin-top: 15px;
            padding: 15px;
            background-color: #282c34;
            border-radius: 8px;
            text-align: center;
        }
        #session-stats h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #61dafb;
        }
        #session-stats p {
            margin: 5px 0;
            font-size: 0.95em;
        }
        #session-stats .stat-value {
            font-weight: bold;
            color: #fff;
        }
        #session-stats .percentage {
            color: #aaa;
        }

        #new-session-button {
            display: block;
            margin: 20px auto 0 auto; /* Center the button */
            background-color: #E53E3E; /* Red */
        }
        #new-session-button:hover:not(:disabled) {
            background-color: #C53030; /* Darker Red */
        }


        /* Basic Strategy Table Container */
        #strategy-guide-container {
            flex: 1; 
            background-color: #1a1e24; 
            border-radius: 15px;     
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); 
            padding: 20px;           
            color: #e0e0e0;
            font-size: 0.9em;
            text-align: left;
            max-height: calc(100vh - 40px); 
            overflow-y: auto;
            overflow-x: hidden; 
        }

        .bs-table h3 { 
            margin-top: 0;
            margin-bottom: 10px;
            color: #61dafb;
            text-align: center;
        }
        
        #strategy-guide-container p { 
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        /* Tab Styles */
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #444;
        }

        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            color: #a8a8a8;
            font-size: 1em;
            font-weight: bold;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px; 
            transition: color 0.3s ease, border-color 0.3s ease;
            flex-grow: 1; 
            text-align: center; 
        }

        .tab-button:hover {
            color: #61dafb;
        }

        .tab-button.active {
            color: #61dafb;
            border-bottom-color: #61dafb;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content h4 {
            color: #a8a8a8;
            text-align: center;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        /* Styling for tables within the strategy guide */
        .bs-table table { /* Applied to strategy tables, reused for history table via id */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .bs-table th, .bs-table td {
            border: 1px solid #444;
            padding: 6px 4px; 
            text-align: center;
            font-size: 0.85em; 
        }

        .bs-table th {
            background-color: #333;
            color: #61dafb;
            font-size: 0.9em; 
        }

        .bs-table tr:nth-child(even) {
            background-color: #222;
        }

        .bs-table .bs-action {
            font-weight: bold;
        }

        /* Color coding for strategy table cells */
        .bs-table td.bs-s { background-color: #5A677D; color: #e0e0e0; } 
        .bs-table td.bs-h { background-color: #D69E2E; color: #282c34; } 
        .bs-table td.bs-d { background-color: #38A169; color: #FFFFFF; } 
        .bs-table td.bs-p { background-color: #805AD5; color: #FFFFFF; } 
        .bs-table td.bs-r { background-color: #E53E3E; color: #FFFFFF; } 

        .bs-table td.bs-s,
        .bs-table td.bs-h,
        .bs-table td.bs-d,
        .bs-table td.bs-p,
        .bs-table td.bs-r {
            font-weight: bold;
        }


        @media (max-width: 1200px) { 
            body {
                flex-direction: column;
                align-items: center; 
            }

            .main-game-area, /* This will stack above strategy guide */
            #strategy-guide-container {
                flex: none; 
                width: 100%; 
                max-width: 900px; 
                margin-left: 0; 
                margin-bottom: 20px; 
            }
            
            #history-log-container {
                max-height: 300px; /* Adjust height for stacked view */
            }

            #strategy-guide-container {
                max-height: 70vh; 
                padding: 15px; 
            }
            .bs-table th, .bs-table td,
            #history-table th, #history-table td {
                padding: 4px 2px;
                font-size: 0.8em;
            }
            .tab-button {
                font-size: 0.9em;
                padding: 8px 10px;
            }
        }
         @media (max-width: 768px) {
            .bs-table th, .bs-table td,
            #history-table th, #history-table td {
                font-size: 0.75em; 
                padding: 3px 1px;
            }
            #history-table td { /* Ensure actions column can wrap */
                word-break: break-word;
            }
            .tab-button {
                font-size: 0.8em;
            }
            .tab-content h4 {
                font-size: 1.1em;
            }
             #strategy-guide-container {
                font-size: 0.85em; 
            }
            #history-log-container {
                font-size: 0.8em;
            }
            #session-stats p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="main-game-area">
        <div class="game-container">
            <h1>Blackjack Trainer</h1>

            <div class="game-area">
                <div class="dealer-area">
                    <h2>Dealer's Hand</h2>
                    <div id="dealer-cards" class="cards"></div>
                    <div id="dealer-score" class="score"></div>
                </div>

                <div class="player-area">
                    <h2>Your Hand</h2>
                    <div id="player-cards" class="cards"></div>
                    <div id="player-score" class="score"></div>
                </div>
            </div>

            <div class="actions">
                <button id="hit-button" class="action-button">Hit</button>
                <button id="stand-button" class="action-button">Stand</button>
                <button id="double-button" class="action-button">Double Down</button>
                <button id="split-button" class="action-button">Split</button>
                <button id="surrender-button" class="action-button">Surrender</button>
                <button id="new-game-button" class="action-button new-game-button">New Game</button>
            </div>

            <div id="message" class="message">Click "New Game" to start.</div>
        </div>

        <div id="history-log-container">
            <h2>Game History</h2>
            <table id="history-table">
                <thead>
                    <tr>
                        <th>Player Initial</th>
                        <th>Dealer Upcard</th>
                        <th>Player Actions &amp; (Correctness)</th>
                        <th>Player Final</th>
                        <th>Dealer Final</th>
                        <th>Result</th>
                    </tr>
                </thead>
                <tbody id="history-table-body">
                    <!-- History rows will be appended here by JavaScript -->
                </tbody>
            </table>
            <div id="session-stats">
                <h3>Session Statistics</h3>
                <p>Correct Decisions: <span id="correct-moves" class="stat-value">0</span> (<span id="correct-moves-percent" class="percentage">0%</span>)</p>
                <p>Incorrect Decisions: <span id="incorrect-moves" class="stat-value">0</span> (<span id="incorrect-moves-percent" class="percentage">0%</span>)</p>
                <p>Total Decisions: <span id="total-decisions" class="stat-value">0</span></p>
                <hr style="border-color: #444; margin: 10px 0;">
                <p>Wins: <span id="wins-count" class="stat-value">0</span> (<span id="wins-percent" class="percentage">0%</span>)</p>
                <p>Losses: <span id="losses-count" class="stat-value">0</span> (<span id="losses-percent" class="percentage">0%</span>)</p>
                <p>Pushes: <span id="pushes-count" class="stat-value">0</span> (<span id="pushes-percent" class="percentage">0%</span>)</p>
                <p>Total Hands Played: <span id="total-hands-played" class="stat-value">0</span></p>
            </div>
            <button id="new-session-button" class="action-button new-game-button">New Session</button>
        </div>
    </div>

    <div id="strategy-guide-container" class="bs-table">
        <h3>Basic Strategy Reference (H17, DAS)</h3>
        <p>S: Stand, H: Hit, D: Double Down, P: Split, R: Surrender (R/H means Surrender if allowed, else Hit)</p>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="hard">Hard</button>
            <button class="tab-button" data-tab="soft">Soft</button>
            <button class="tab-button" data-tab="pairs">Pairs</button>
        </div>

        <div id="hard-tab" class="tab-content active">
            <h4>Hard Totals</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>17-21</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>16</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>15</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>14</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>13</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>12</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>11</b></td><td colspan="10" class="bs-action bs-d">D</td></tr>
                    <tr><td><b>10</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>9</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5-8</b></td><td colspan="10" class="bs-action bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="soft-tab" class="tab-content">
            <h4>Soft Totals (Ace + Card)</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,9 (S20)</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>A,8 (S19)</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>A,7 (S18)</b></td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,6 (S17)</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,5 (S16)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,4 (S15)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,3 (S14)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,2 (S13)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="pairs-tab" class="tab-content">
            <h4>Pairs</h4>
            <table>
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,A</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>10,10</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>9,9</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>8,8</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>7,7</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>6,6</b></td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5,5</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>4,4</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>3,3</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>2,2</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // --- Game State Variables ---
        let deck = [];
        let playerHands = []; 
        let currentHandIndex = 0;
        let dealerHand = [];
        let gameActive = false;
        let canSurrender = false; 

        // --- History and Stats Variables ---
        let gameHistoryLog = [];
        let sessionStats = {
            correctMoves: 0,
            incorrectMoves: 0,
            totalDecisions: 0,
            wins: 0,
            losses: 0,
            pushes: 0,
            handsPlayed: 0
        };

        // --- DOM Elements ---
        const dealerCardsDiv = document.getElementById('dealer-cards');
        const dealerScoreDiv = document.getElementById('dealer-score');
        const playerCardsDiv = document.getElementById('player-cards');
        const playerScoreDiv = document.getElementById('player-score');
        const messageDiv = document.getElementById('message');

        const hitButton = document.getElementById('hit-button');
        const standButton = document.getElementById('stand-button');
        const doubleButton = document.getElementById('double-button');
        const splitButton = document.getElementById('split-button');
        const surrenderButton = document.getElementById('surrender-button');
        const newGameButton = document.getElementById('new-game-button');

        // History DOM Elements
        const historyTableBody = document.getElementById('history-table-body');
        const correctMovesSpan = document.getElementById('correct-moves');
        const correctMovesPercentSpan = document.getElementById('correct-moves-percent');
        const incorrectMovesSpan = document.getElementById('incorrect-moves');
        const incorrectMovesPercentSpan = document.getElementById('incorrect-moves-percent');
        const totalDecisionsSpan = document.getElementById('total-decisions');
        const winsCountSpan = document.getElementById('wins-count');
        const winsPercentSpan = document.getElementById('wins-percent');
        const lossesCountSpan = document.getElementById('losses-count');
        const lossesPercentSpan = document.getElementById('losses-percent');
        const pushesCountSpan = document.getElementById('pushes-count');
        const pushesPercentSpan = document.getElementById('pushes-percent');
        const totalHandsPlayedSpan = document.getElementById('total-hands-played');
        const newSessionButton = document.getElementById('new-session-button');


        // --- Card Data ---
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const values = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 10, 'Q': 10, 'K': 10, 'A': 11
        };

        // --- Core Game Functions ---

        function createDeck() {
            deck = [];
            for (let i = 0; i < 6; i++) { 
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push({ rank, suit, value: values[rank] });
                    }
                }
            }
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function dealCard() {
            if (deck.length < 20) { 
                createDeck();
                messageDiv.textContent = "Shuffling a new shoe!";
            }
            return deck.pop();
        }

        function calculateHandValue(hand) {
            let value = 0;
            let numAces = 0;
            for (const card of hand) {
                value += card.value;
                if (card.rank === 'A') {
                    numAces++;
                }
            }
            while (value > 21 && numAces > 0) {
                value -= 10;
                numAces--;
            }
            return value;
        }

        function getHandScoreText(hand) {
            const value = calculateHandValue(hand);
            let text = `${value}`;
            const hasAce = hand.some(card => card.rank === 'A');
            if (hasAce) {
                let valueWithoutOneAce = 0;
                let acesFound = 0;
                for (const card of hand) {
                    if (card.rank === 'A' && acesFound === 0) {
                        valueWithoutOneAce += 1; 
                        acesFound++;
                    } else {
                        valueWithoutOneAce += card.value;
                    }
                }
                if (valueWithoutOneAce + 10 <= 21 && value === valueWithoutOneAce + 10) {
                     text += " (Soft)";
                }
            }
            return text;
        }


        function displayCards(hand, element, hideFirst = false) {
            element.innerHTML = '';
            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                const shouldBeHidden = (index === 0 && hideFirst && gameActive && playerHands.length > 0 && currentHandIndex < playerHands.length && playerHands[currentHandIndex] && !playerHands[currentHandIndex].stood && !playerHands[currentHandIndex].busted);


                if (shouldBeHidden) {
                    cardDiv.classList.add('hidden');
                    cardDiv.innerHTML = ''; 
                } else {
                    cardDiv.innerHTML = `<div class="rank">${card.rank}</div><div class="suit">${card.suit}</div>`;
                    if (card.suit === '♥' || card.suit === '♦') {
                        cardDiv.classList.add('red');
                    }
                }
                element.appendChild(cardDiv);
            });
        }

        function updateDisplay() {
            if (playerHands.length > 0 && currentHandIndex < playerHands.length && playerHands[currentHandIndex]) {
                const currentHand = playerHands[currentHandIndex];
                displayCards(currentHand.cards, playerCardsDiv);
                playerScoreDiv.textContent = `Score: ${getHandScoreText(currentHand.cards)}`;
                if (playerHands.length > 1) {
                    playerScoreDiv.textContent += ` (Hand ${currentHandIndex + 1}/${playerHands.length})`;
                }
            } else {
                playerCardsDiv.innerHTML = '';
                playerScoreDiv.textContent = '';
            }

            const allPlayerHandsDone = playerHands.every(hand => hand.busted || hand.stood || hand.surrendered);
            const hideDealerFirstCard = gameActive && !allPlayerHandsDone;
            displayCards(dealerHand, dealerCardsDiv, hideDealerFirstCard);

            if (hideDealerFirstCard) {
                dealerScoreDiv.textContent = `Score: ?`;
            } else if (dealerHand.length > 0) {
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
            } else {
                dealerScoreDiv.textContent = '';
            }
            
            const currentHand = (currentHandIndex < playerHands.length) ? playerHands[currentHandIndex] : null;
            const isPlayerTurn = gameActive && currentHand && !currentHand.busted && !currentHand.stood && !currentHand.surrendered;
            const hasInitialTwoCards = currentHand && currentHand.cards.length === 2 && !currentHand.splitFromPair;


            hitButton.disabled = !isPlayerTurn;
            standButton.disabled = !isPlayerTurn;
            doubleButton.disabled = !isPlayerTurn || !hasInitialTwoCards;
            // Allow split only if less than 4 hands already
            splitButton.disabled = !isPlayerTurn || !hasInitialTwoCards || !currentHand.cards[0] || !currentHand.cards[1] || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4;
            surrenderButton.disabled = !isPlayerTurn || !canSurrender || (currentHand && currentHand.cards.length > 2);
        }

        function resetGame() { // Resets board for a new hand, not session
            gameActive = false;
            playerHands = [];
            dealerHand = [];
            currentHandIndex = 0;
            canSurrender = false;
            messageDiv.className = 'message';
            messageDiv.textContent = 'Click "New Game" to start.';
            playerCardsDiv.innerHTML = '';
            dealerCardsDiv.innerHTML = '';
            playerScoreDiv.textContent = '';
            dealerScoreDiv.textContent = '';
            newGameButton.disabled = false;
            disableActionButtons();
            updateDisplay(); 
        }

        async function newGame() {
            resetGame(); 
            createDeck(); 
            gameActive = true;
            canSurrender = true; 

            const newPlayerHand = { 
                cards: [], 
                busted: false, 
                stood: false, 
                doubled: false, 
                splitFromPair: false, 
                surrendered: false,
                initialCardsForThisHand: [], // For history log
                actionsTakenLog: []         // For history log
            };
            playerHands.push(newPlayerHand);
            dealerHand = [];

            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 
            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 

            playerHands[0].initialCardsForThisHand = [...playerHands[0].cards]; // Log initial state

            updateDisplay(); 

            const playerBlackjack = calculateHandValue(playerHands[0].cards) === 21;
            const dealerBlackjack = calculateHandValue(dealerHand) === 21;

            if (dealerBlackjack || playerBlackjack) {
                gameActive = false; 
                displayCards(dealerHand, dealerCardsDiv, false); 
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
                if (dealerBlackjack && playerBlackjack) {
                    messageDiv.textContent = "Push! Both have Blackjack.";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                } else if (dealerBlackjack) {
                    messageDiv.textContent = "Dealer has Blackjack! You lose.";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                } else { // Player Blackjack
                    messageDiv.textContent = "Blackjack! You win!";
                    playerHands[0].stood = true; // Mark as resolved
                    resolveGame(); // Log this outcome
                }
                newGameButton.disabled = false;
                disableActionButtons();
                return;
            }

            messageDiv.textContent = "Your turn. What's your move?";
            updateDisplay(); 
        }

        function disableActionButtons() {
            hitButton.disabled = true;
            standButton.disabled = true;
            doubleButton.disabled = true;
            splitButton.disabled = true;
            surrenderButton.disabled = true;
        }
        
        function recordAction(playerActionCode, handValueBefore, handValueAfter) {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex]) return;
            const currentHand = playerHands[currentHandIndex];
            const dealerUpCard = dealerHand[0];
            
            const mistakeInfo = checkAndHighlightMistake(playerActionCode, currentHand.cards, dealerUpCard);

            currentHand.actionsTakenLog.push({
                playerAction: playerActionCode,
                optimalAction: mistakeInfo.optimalMoveForLog,
                wasCorrect: !mistakeInfo.isMistake,
                handValueBefore: handValueBefore,
                handValueAfter: handValueAfter 
            });

            sessionStats.totalDecisions++;
            if (mistakeInfo.isMistake) {
                sessionStats.incorrectMoves++;
            } else {
                sessionStats.correctMoves++;
            }
            // renderSessionStats(); // Update stats display immediately or wait till resolveGame
        }


        async function playerHit() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            canSurrender = false; 
            const currentHand = playerHands[currentHandIndex];
            const handValueBefore = calculateHandValue(currentHand.cards);
            
            currentHand.cards.push(dealCard());
            const handValueAfter = calculateHandValue(currentHand.cards);
            recordAction('H', handValueBefore, handValueAfter); // Call recordAction *after* card is dealt for H,D
            updateDisplay(); 

            if (handValueAfter > 21) {
                currentHand.busted = true;
                messageDiv.textContent = `Hand ${currentHandIndex + 1} busted! Score: ${handValueAfter}`;
                // messageDiv.classList.add('error'); // checkAndHighlightMistake handles class
                await nextHandOrDealerTurn();
            } else if (handValueAfter === 21) {
                currentHand.stood = true; 
                await nextHandOrDealerTurn();
            }
        }

        async function playerStand() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;
            
            canSurrender = false;
            const currentHand = playerHands[currentHandIndex];
            const handValue = calculateHandValue(currentHand.cards);
            recordAction('S', handValue, handValue); // handValue doesn't change
            currentHand.stood = true;
            updateDisplay();
            await nextHandOrDealerTurn(); 
        }

        async function playerDoubleDown() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.splitFromPair) { 
                messageDiv.textContent = "Can only double down on your first two cards (not after split)!";
                messageDiv.classList.add('error');
                return;
            }
            canSurrender = false;
            
            const handValueBefore = calculateHandValue(currentHand.cards);
            currentHand.doubled = true;
            currentHand.cards.push(dealCard());
            const handValueAfter = calculateHandValue(currentHand.cards);
            recordAction('D', handValueBefore, handValueAfter);
            updateDisplay();

            if (handValueAfter > 21) {
                currentHand.busted = true;
            }
            currentHand.stood = true; 
            await nextHandOrDealerTurn();
        }

        async function playerSplit() {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4) {
                messageDiv.textContent = "Cannot split this hand!";
                messageDiv.classList.add('error');
                return;
            }
            canSurrender = false;
            const handValueBeforeSplit = calculateHandValue(currentHand.cards);
            recordAction('P', handValueBeforeSplit, handValueBeforeSplit); // Record split decision

            const card1 = currentHand.cards[0];
            const card2 = currentHand.cards[1];

            // Create first new hand (replaces current)
            const hand1Cards = [card1, dealCard()];
            playerHands[currentHandIndex] = { 
                cards: hand1Cards, 
                busted: false, stood: false, doubled: false, 
                splitFromPair: true, surrendered: false,
                initialCardsForThisHand: [...hand1Cards], // Log initial state of this split hand
                actionsTakenLog: [] 
            };

            // Create second new hand (inserted after current)
            const hand2Cards = [card2, dealCard()];
            playerHands.splice(currentHandIndex + 1, 0, { 
                cards: hand2Cards, 
                busted: false, stood: false, doubled: false, 
                splitFromPair: true, surrendered: false,
                initialCardsForThisHand: [...hand2Cards], // Log initial state of this split hand
                actionsTakenLog: []
            });
            
            updateDisplay();

            // Handle Aces - only one card, then stand
            if (card1.rank === 'A') {
                playerHands[currentHandIndex].stood = true;
                if (playerHands[currentHandIndex+1]) playerHands[currentHandIndex+1].stood = true; 
            }
            
            if (playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) {
                 await nextHandOrDealerTurn(); 
            } else {
                updateDisplay(); 
                messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`;
            }
        }

        async function playerSurrender() {
            if (!gameActive || !canSurrender || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].cards.length > 2) {
                 messageDiv.textContent = "Cannot surrender now.";
                 messageDiv.classList.add('error');
                 return;
            }
            
            const currentHand = playerHands[currentHandIndex];
            const handValue = calculateHandValue(currentHand.cards);
            recordAction('R', handValue, handValue); 
            currentHand.surrendered = true;
            currentHand.stood = true; 
            canSurrender = false;
            updateDisplay();
            await nextHandOrDealerTurn(); 
        }

        async function nextHandOrDealerTurn() {
            let nextHandFound = false;
            // Start searching from the current hand index IF it's resolved
            let searchStartIndex = currentHandIndex;
            if (playerHands[currentHandIndex] && (playerHands[currentHandIndex].busted || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].surrendered)) {
                searchStartIndex = currentHandIndex + 1; // Move to check next hand
            }
            
            for (let i = searchStartIndex; i < playerHands.length; i++) {
                if (!playerHands[i].busted && !playerHands[i].stood && !playerHands[i].surrendered) {
                    currentHandIndex = i;
                    nextHandFound = true;
                    break;
                }
            }
             // If no next hand found from searchStartIndex, but currentHandIndex itself is playable (e.g. after split, first new hand is active)
            if (!nextHandFound && playerHands[currentHandIndex] && !playerHands[currentHandIndex].busted && !playerHands[currentHandIndex].stood && !playerHands[currentHandIndex].surrendered) {
                nextHandFound = true; // Stay on current hand
            }


            if (nextHandFound) {
                updateDisplay();
                messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`;
                const currentActiveHand = playerHands[currentHandIndex];
                canSurrender = currentActiveHand.cards.length === 2 && !currentActiveHand.splitFromPair; 
            } else {
                await dealerTurn();
            }
        }

        async function dealerTurn() {
            gameActive = false; 
            disableActionButtons(); 
            newGameButton.disabled = true; 

            const allPlayerHandsResolvedEarly = playerHands.every(hand => hand.busted || hand.surrendered);
            if (allPlayerHandsResolvedEarly && playerHands.length > 0) {
                messageDiv.textContent = "All player hands resolved. Dealer's turn skipped.";
                updateDisplay(); // Reveal dealer's hand
                await new Promise(resolve => setTimeout(resolve, 1000));
                resolveGame();
                return;
            }

            messageDiv.textContent = "Dealer's turn...";
            updateDisplay(); 
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            let dealerValue = calculateHandValue(dealerHand);
            while (dealerValue < 17 || (dealerValue === 17 && dealerHand.some(card => card.rank === 'A' && calculateHandValue(dealerHand.filter(c => c !== card)) + 11 === dealerValue))) {
                if (dealerValue >= 21) break; 
                messageDiv.textContent = `Dealer hits (score: ${getHandScoreText(dealerHand)}).`;
                await new Promise(resolve => setTimeout(resolve, 1500)); 
                dealerHand.push(dealCard());
                dealerValue = calculateHandValue(dealerHand);
                updateDisplay();
            }

            await new Promise(resolve => setTimeout(resolve, 1000)); 

            if (dealerValue > 21) {
                messageDiv.textContent = `Dealer busts! (${dealerValue}).`;
            } else {
                messageDiv.textContent = `Dealer stands on ${getHandScoreText(dealerHand)}.`;
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            resolveGame();
        }

        function resolveGame() {
            const dealerValue = calculateHandValue(dealerHand);
            const dealerBusted = dealerValue > 21;
            let finalMessageParts = ["<h3>Game Over</h3>"];

            playerHands.forEach((hand, index) => {
                sessionStats.handsPlayed++;
                const playerValue = calculateHandValue(hand.cards);
                let handResultText = `Hand ${index + 1} (${playerValue}): `;
                let resultOutcome;

                if (hand.surrendered) {
                    handResultText += "Surrendered. You lose.";
                    resultOutcome = "Loss";
                    sessionStats.losses++;
                } else if (hand.busted) {
                    handResultText += "Busted. You lose.";
                    resultOutcome = "Bust";
                    sessionStats.losses++;
                } else if (dealerBusted) {
                    handResultText += "Dealer busts. You win!";
                    resultOutcome = "Win";
                    sessionStats.wins++;
                } else if (playerValue > dealerValue) {
                    handResultText += `You win! (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Win";
                    sessionStats.wins++;
                } else if (playerValue < dealerValue) {
                    handResultText += `You lose. (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Loss";
                    sessionStats.losses++;
                } else { 
                    handResultText += `Push. (${playerValue} vs Dealer ${dealerValue})`;
                    resultOutcome = "Push";
                    sessionStats.pushes++;
                }
                finalMessageParts.push(`<p>${handResultText}</p>`);

                // Add to game history log
                const historyEntry = {
                    playerInitialDisplay: formatCardsForDisplay(hand.initialCardsForThisHand),
                    dealerUpCardDisplay: dealerHand.length > 0 ? formatCardForDisplay(dealerHand[0]) : "N/A",
                    actionsSummary: formatActionsLogForDisplay(hand.actionsTakenLog),
                    playerFinalDisplay: `${playerValue}${hand.busted ? ' (Bust)' : ''}${hand.surrendered ? ' (Surrender)' : ''}`,
                    dealerFinalDisplay: `${dealerValue}${dealerBusted ? ' (Bust)' : ''}`,
                    result: resultOutcome,
                    isSplit: hand.splitFromPair
                };
                gameHistoryLog.push(historyEntry);
            });
            
            messageDiv.innerHTML = finalMessageParts.join('');
            messageDiv.className = 'message'; 

            renderHistoryTable();
            renderSessionStats();

            newGameButton.disabled = false; 
            disableActionButtons(); 
            updateDisplay(); 
        }

        // --- Basic Strategy Logic (H17, DAS) ---
        function getOptimalPlay(playerHandCards, dealerUpCard, canSplit, canDouble, canSurrenderNow) {
            const playerValue = calculateHandValue(playerHandCards);
            const dealerCardValue = dealerUpCard.value; 
            const dealerIsAce = dealerUpCard.rank === 'A';
            const dealerIsTen = dealerCardValue === 10;

            const isPlayerPair = playerHandCards.length === 2 && playerHandCards[0].rank === playerHandCards[1].rank;
            let isPlayerSoft = false;
            if (playerHandCards.some(c => c.rank === 'A')) {
                let nonAceTotal = 0;
                let aceCount = 0;
                playerHandCards.forEach(c => {
                    if (c.rank === 'A') aceCount++; else nonAceTotal += c.value;
                });
                if (aceCount > 0 && nonAceTotal + 11 + (aceCount - 1) === playerValue && playerValue <= 21) {
                    isPlayerSoft = true;
                }
            }
            
            if (canSurrenderNow && playerHandCards.length === 2 && !isPlayerPair) { 
                if (playerValue === 16 && (dealerUpCard.rank === '9' || dealerIsTen || dealerIsAce)) return 'R';
                if (playerValue === 15 && (dealerIsTen || dealerIsAce)) return 'R'; // Adjusted for H17 common surrender
            }

            if (isPlayerPair && canSplit) {
                const pRank = playerHandCards[0].rank;
                if (pRank === 'A') return 'P';
                if (pRank === '10' || pRank === 'J' || pRank === 'Q' || pRank === 'K') return 'S'; 
                if (pRank === '9') {
                    if (dealerCardValue === 7 || dealerIsTen || dealerIsAce) return 'S';
                    return 'P';
                }
                if (pRank === '8') return 'P'; 
                if (pRank === '7') return (dealerCardValue >= 2 && dealerCardValue <= 7) ? 'P' : 'H';
                if (pRank === '6') return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'P' : 'H'; 
                if (pRank === '5') return (canDouble && dealerCardValue >= 2 && dealerCardValue <= 9) ? 'D' : 'H'; 
                if (pRank === '4') { 
                    if (canDouble && (dealerCardValue === 5 || dealerCardValue === 6)) return 'P'; // P/H (Split if DAS, else Hit)
                    return 'H';
                }
                if (pRank === '3' || pRank === '2') {
                    if (dealerCardValue >= 2 && dealerCardValue <= 7) return 'P'; 
                    return 'H';
                }
            }

            if (isPlayerSoft) {
                if (playerValue >= 20) return 'S'; 
                if (playerValue === 19) { 
                     return (canDouble && dealerCardValue === 6) ? 'D' : 'S'; 
                }
                if (playerValue === 18) { 
                    if (canDouble && dealerCardValue >= 2 && dealerCardValue <= 6) return 'D'; 
                    if (dealerCardValue <= 8) return 'S';
                    return 'H';
                }
                if (playerValue === 17) { 
                    if (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 16 || playerValue === 15) { 
                    if (canDouble && dealerCardValue >= 4 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 14 || playerValue === 13) { 
                    if (canDouble && dealerCardValue >= 5 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
            }

            // Hard Totals (also fallback for pairs/soft not meeting specific conditions)
            if (playerValue >= 17) return 'S';
            if (playerValue === 16) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 15) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 14) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 13) return (dealerCardValue >= 2 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 12) return (dealerCardValue >= 4 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 11) return canDouble ? 'D' : 'H';
            if (playerValue === 10) return (canDouble && dealerCardValue >= 2 && dealerCardValue <= 9) ? 'D' : 'H';
            if (playerValue === 9) return (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) ? 'D' : 'H';
            if (playerValue <= 8) return 'H';

            return 'H'; 
        }


        function checkAndHighlightMistake(playerAction, playerHandCards, dealerUpCard) {
            if (!gameActive || currentHandIndex >= playerHands.length || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) {
                return { optimalMoveForLog: playerAction, isMistake: false }; // No check if not relevant
            }

            const currentFullHand = playerHands[currentHandIndex];
            if (currentFullHand.stood || currentFullHand.busted) { // Already resolved (e.g. split aces)
                 return { optimalMoveForLog: playerAction, isMistake: false };
            }

            const actualCanDouble = currentFullHand.cards.length === 2 && !currentFullHand.splitFromPair;
            const actualCanSplit = actualCanDouble && currentFullHand.cards[0].rank === currentFullHand.cards[1].rank && playerHands.length < 4;
            const actualCanSurrenderGlobal = canSurrender && currentFullHand.cards.length === 2 && !currentFullHand.splitFromPair;

            const optimalSingleMove = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, actualCanDouble, actualCanSurrenderGlobal);
            
            const isMistake = (playerAction !== optimalSingleMove);
            const chosenActionText = mapActionCodeToText(playerAction);
            const optimalActionText = mapActionCodeToText(optimalSingleMove);

            if (isMistake) {
                messageDiv.textContent = `Mistake! You chose ${chosenActionText}. Optimal: ${optimalActionText}.`;
                messageDiv.classList.add('error');
            } else {
                messageDiv.textContent = `Correct! You chose ${chosenActionText}. (Optimal: ${optimalActionText})`;
                messageDiv.classList.remove('error');
                // messageDiv.classList.add('message'); // Already has 'message' or will be set by game flow
            }
            return { optimalMoveForLog: optimalSingleMove, isMistake: isMistake };
        }

        function mapActionCodeToText(code) {
            if (!code) return "Unknown";
            switch (code) {
                case 'H': return 'Hit';
                case 'S': return 'Stand';
                case 'D': return 'Double';
                case 'P': return 'Split';
                case 'R': return 'Surrender';
                default: return `Unknown (${code})`;
            }
        }

        // --- History Log and Stats Functions ---
        function formatCardForDisplay(card) {
            if (!card) return "N/A";
            return `${card.rank}${card.suit}`;
        }

        function formatCardsForDisplay(cardsArray) {
            if (!cardsArray || cardsArray.length === 0) return "N/A";
            return cardsArray.map(card => formatCardForDisplay(card)).join(', ');
        }

        function formatActionsLogForDisplay(actionsLogArray) {
            if (!actionsLogArray || actionsLogArray.length === 0) return "N/A";
            return actionsLogArray.map(log => {
                let valChange = "";
                if (log.playerAction === 'H' || log.playerAction === 'D') {
                    valChange = ` (${log.handValueBefore}→${log.handValueAfter})`;
                } else {
                    valChange = ` (${log.handValueBefore})`;
                }
                const correctness = log.wasCorrect ? `Correct: ${mapActionCodeToText(log.optimalAction)}` : `Mistake (Optimal: ${mapActionCodeToText(log.optimalAction)})`;
                return `${mapActionCodeToText(log.playerAction)}${valChange}, ${correctness}`;
            }).join('; ');
        }

        function renderHistoryTable() {
            historyTableBody.innerHTML = ''; // Clear existing rows
            gameHistoryLog.slice().reverse().forEach(entry => { // Newest first
                const row = historyTableBody.insertRow();
                row.insertCell().textContent = entry.playerInitialDisplay;
                row.insertCell().textContent = entry.dealerUpCardDisplay;
                
                const actionsCell = row.insertCell();
                actionsCell.innerHTML = entry.actionsSummary.replace(/Correct:/g, '<span class="action-correct">Correct:</span>')
                                                          .replace(/Mistake/g, '<span class="action-mistake">Mistake</span>');

                row.insertCell().textContent = entry.playerFinalDisplay;
                row.insertCell().textContent = entry.dealerFinalDisplay;
                row.insertCell().textContent = entry.result;
            });
        }

        function renderSessionStats() {
            correctMovesSpan.textContent = sessionStats.correctMoves;
            incorrectMovesSpan.textContent = sessionStats.incorrectMoves;
            totalDecisionsSpan.textContent = sessionStats.totalDecisions;

            correctMovesPercentSpan.textContent = sessionStats.totalDecisions > 0 ? ((sessionStats.correctMoves / sessionStats.totalDecisions) * 100).toFixed(1) + '%' : '0%';
            incorrectMovesPercentSpan.textContent = sessionStats.totalDecisions > 0 ? ((sessionStats.incorrectMoves / sessionStats.totalDecisions) * 100).toFixed(1) + '%' : '0%';

            winsCountSpan.textContent = sessionStats.wins;
            lossesCountSpan.textContent = sessionStats.losses;
            pushesCountSpan.textContent = sessionStats.pushes;
            totalHandsPlayedSpan.textContent = sessionStats.handsPlayed;

            winsPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.wins / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
            lossesPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.losses / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
            pushesPercentSpan.textContent = sessionStats.handsPlayed > 0 ? ((sessionStats.pushes / sessionStats.handsPlayed) * 100).toFixed(1) + '%' : '0%';
        }

        function startNewSession() {
            gameHistoryLog = [];
            sessionStats = {
                correctMoves: 0, incorrectMoves: 0, totalDecisions: 0,
                wins: 0, losses: 0, pushes: 0, handsPlayed: 0
            };
            renderHistoryTable();
            renderSessionStats();
            newGame(); // Start a fresh game on the board
        }


        // --- Tab Functionality for Strategy Guide ---
        const tabButtons = document.querySelectorAll('#strategy-guide-container .tab-button');
        const tabContents = document.querySelectorAll('#strategy-guide-container .tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const tabId = button.dataset.tab;
                const targetTabContent = document.getElementById(tabId + '-tab');
                if (targetTabContent) {
                    targetTabContent.classList.add('active');
                }
            });
        });

        // --- Event Listeners ---
        newGameButton.addEventListener('click', newGame);
        hitButton.addEventListener('click', playerHit);
        standButton.addEventListener('click', playerStand);
        doubleButton.addEventListener('click', playerDoubleDown);
        splitButton.addEventListener('click', playerSplit);
        surrenderButton.addEventListener('click', playerSurrender);
        newSessionButton.addEventListener('click', startNewSession);

        // Initial setup
        resetGame();
        renderSessionStats(); // Initialize stats display
    </script>
</body>
</html>
