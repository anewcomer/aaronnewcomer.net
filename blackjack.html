<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Trainer</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            /* justify-content: center; Will be handled by flex properties of children */
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh;
            background-color: #282c34;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between game container and strategy table */
        }

        .game-container {
            background-color: #1a1e24;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            text-align: center;
            flex: 3; /* Takes up 3/4 of the space */
            /* max-width: 900px; Removed for flex, applied in media query */
            /* width: 100%; Removed for flex */
        }

        h1 {
            color: #61dafb;
            margin-bottom: 25px;
            font-size: 2.5em;
        }

        .game-area {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            gap: 20px;
        }

        .player-area, .dealer-area {
            background-color: #3a3f4a;
            border-radius: 10px;
            padding: 20px;
            flex: 1;
            min-height: 200px;
            position: relative;
        }

        h2 {
            color: #a8a8a8;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            min-height: 80px; /* Ensure space for cards */
        }

        .card {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 70px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .card.hidden {
            background-color: #888;
            color: #888;
            border: 1px solid #555;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="100" viewBox="0 0 70 100"><rect x="0" y="0" width="70" height="100" fill="%23888"/><line x1="0" y1="0" x2="70" y2="100" stroke="%23555" stroke-width="2"/><line x1="70" y1="0" x2="0" y2="100" stroke="%23555" stroke-width="2"/><circle cx="35" cy="50" r="15" fill="%23666"/></svg>');
            background-size: cover;
        }

        .card .rank {
            font-size: 1.5em;
            line-height: 1;
        }

        .card .suit {
            font-size: 1em;
            line-height: 1;
        }

        .card.red {
            color: red;
        }

        .score {
            font-size: 1.8em;
            font-weight: bold;
            color: #61dafb;
        }

        .actions {
            margin-top: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }

        .action-button {
            background-color: #61dafb;
            color: #282c34;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .action-button:hover:not(:disabled) {
            background-color: #21a1f1;
            transform: translateY(-2px);
        }

        .action-button:disabled {
            background-color: #555;
            color: #aaa;
            cursor: not-allowed;
            box-shadow: none;
        }

        .new-game-button {
            background-color: #4CAF50;
        }

        .new-game-button:hover:not(:disabled) {
            background-color: #45a049;
        }

        .message {
            margin-top: 20px;
            font-size: 1.4em;
            font-weight: bold;
            min-height: 30px;
            color: #fdd835; /* Yellowish for info */
        }

        .message.error {
            color: #ef5350; /* Red for errors/mistakes */
        }

        /* Basic Strategy Table Container */
        #strategy-guide-container {
            flex: 1; /* Takes up 1/4 of the space */
            background-color: #1a1e24; /* Match game-container */
            border-radius: 15px;     /* Match game-container */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); /* Match game-container */
            padding: 20px;           /* Reduced padding slightly for tabs */
            color: #e0e0e0;
            font-size: 0.9em;
            text-align: left;
            max-height: calc(100vh - 40px); /* Full viewport height minus body padding */
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scroll on container, table might need its own if too wide */
        }

        .bs-table h3 { /* This class is on #strategy-guide-container */
            margin-top: 0;
            margin-bottom: 10px;
            color: #61dafb;
            text-align: center;
        }
        
        #strategy-guide-container p { /* Style for the legend */
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        /* Tab Styles */
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #444;
        }

        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            color: #a8a8a8;
            font-size: 1em;
            font-weight: bold;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px; /* Overlap with container's border-bottom */
            transition: color 0.3s ease, border-color 0.3s ease;
            flex-grow: 1; /* Make buttons share space */
            text-align: center; /* Center text in button */
        }

        .tab-button:hover {
            color: #61dafb;
        }

        .tab-button.active {
            color: #61dafb;
            border-bottom-color: #61dafb;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content h4 {
            color: #a8a8a8;
            text-align: center;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        /* Styling for tables within the strategy guide */
        .bs-table table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .bs-table th, .bs-table td {
            border: 1px solid #444;
            padding: 6px 4px; /* Adjusted padding for better fit */
            text-align: center;
            font-size: 0.85em; /* Slightly smaller font for table cells */
        }

        .bs-table th {
            background-color: #333;
            color: #61dafb;
            font-size: 0.9em; /* Slightly smaller font for table headers */
        }

        .bs-table tr:nth-child(even) {
            background-color: #222;
        }

        .bs-table .bs-action {
            font-weight: bold;
        }

        /* Color coding for strategy table cells */
        .bs-table td.bs-s { background-color: #5A677D; color: #e0e0e0; } /* Stand - Cool Gray */
        .bs-table td.bs-h { background-color: #D69E2E; color: #282c34; } /* Hit - Amber/Dark Yellow */
        .bs-table td.bs-d { background-color: #38A169; color: #FFFFFF; } /* Double - Green */
        .bs-table td.bs-p { background-color: #805AD5; color: #FFFFFF; } /* Split - Purple */
        .bs-table td.bs-r { background-color: #E53E3E; color: #FFFFFF; } /* Surrender - Red */

        /* Ensure text in colored cells is clearly visible and bold */
        .bs-table td.bs-s,
        .bs-table td.bs-h,
        .bs-table td.bs-d,
        .bs-table td.bs-p,
        .bs-table td.bs-r {
            font-weight: bold;
        }

        /* For cells with colspan, ensure the .bs-action styling is preserved or enhanced */
        .bs-table td.bs-action.bs-s,
        .bs-table td.bs-action.bs-h,
        .bs-table td.bs-action.bs-d,
        .bs-table td.bs-action.bs-p,
        .bs-table td.bs-action.bs-r {
            /* font-weight: bold; is already covered */
        }

        @media (max-width: 1200px) { /* Breakpoint for stacking */
            body {
                flex-direction: column;
                align-items: center; /* Center items when stacked */
            }

            .game-container,
            #strategy-guide-container {
                flex: none; /* Reset flex behavior */
                width: 100%; /* Full width when stacked */
                max-width: 900px; /* Max width for readability */
                margin-left: 0; /* Reset side margins */
                margin-bottom: 20px; /* Space between stacked items */
            }

            #strategy-guide-container {
                max-height: 70vh; /* Adjust height for stacked view */
                padding: 15px; /* Adjust padding for smaller screens */
            }
            .bs-table th, .bs-table td {
                padding: 4px 2px;
                font-size: 0.8em;
            }
            .tab-button {
                font-size: 0.9em;
                padding: 8px 10px;
            }
        }
         @media (max-width: 768px) {
            .bs-table th, .bs-table td {
                font-size: 0.75em; /* Even smaller for very small screens */
                padding: 3px 1px;
            }
            .tab-button {
                font-size: 0.8em;
            }
            .tab-content h4 {
                font-size: 1.1em;
            }
             #strategy-guide-container {
                font-size: 0.85em; /* Reduce base font size for strategy guide on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Blackjack Trainer</h1>

        <div class="game-area">
            <div class="dealer-area">
                <h2>Dealer's Hand</h2>
                <div id="dealer-cards" class="cards"></div>
                <div id="dealer-score" class="score"></div>
            </div>

            <div class="player-area">
                <h2>Your Hand</h2>
                <div id="player-cards" class="cards"></div>
                <div id="player-score" class="score"></div>
            </div>
        </div>

        <div class="actions">
            <button id="hit-button" class="action-button">Hit</button>
            <button id="stand-button" class="action-button">Stand</button>
            <button id="double-button" class="action-button">Double Down</button>
            <button id="split-button" class="action-button">Split</button>
            <button id="surrender-button" class="action-button">Surrender</button>
            <button id="new-game-button" class="action-button new-game-button">New Game</button>
        </div>

        <div id="message" class="message">Click "New Game" to start.</div>
    </div>

    <div id="strategy-guide-container" class="bs-table">
        <h3>Basic Strategy Reference (H17, DAS)</h3>
        <p>S: Stand, H: Hit, D: Double Down, P: Split, R: Surrender (R/H means Surrender if allowed, else Hit)</p>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="hard">Hard</button>
            <button class="tab-button" data-tab="soft">Soft</button>
            <button class="tab-button" data-tab="pairs">Pairs</button>
        </div>

        <div id="hard-tab" class="tab-content active">
            <h4>Hard Totals</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>17-21</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>16</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>15</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-r">R/H</td><td class="bs-r">R/H</td></tr>
                    <tr><td><b>14</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>13</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>12</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>11</b></td><td colspan="10" class="bs-action bs-d">D</td></tr>
                    <tr><td><b>10</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>9</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5-8</b></td><td colspan="10" class="bs-action bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="soft-tab" class="tab-content">
            <h4>Soft Totals (Ace + Card)</h4>
            <table>
                <thead>
                    <tr>
                        <th>Hand</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,9 (S20)</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>A,8 (S19)</b></td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>A,7 (S18)</b></td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-d">D/S</td><td class="bs-s">S</td><td class="bs-s">S</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,6 (S17)</b></td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,5 (S16)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,4 (S15)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,3 (S14)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>A,2 (S13)</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>

        <div id="pairs-tab" class="tab-content">
            <h4>Pairs</h4>
            <table>
                <thead>
                    <tr>
                        <th>Pair</th>
                        <th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>A</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><b>A,A</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>10,10</b></td><td colspan="10" class="bs-action bs-s">S</td></tr>
                    <tr><td><b>9,9</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-s">S</td><td class="bs-s">S</td></tr>
                    <tr><td><b>8,8</b></td><td colspan="10" class="bs-action bs-p">P</td></tr>
                    <tr><td><b>7,7</b></td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>6,6</b></td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>5,5</b></td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-d">D</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>4,4</b></td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>3,3</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                    <tr><td><b>2,2</b></td><td class="bs-p">P/H</td><td class="bs-p">P/H</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-p">P</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td><td class="bs-h">H</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // --- Game State Variables ---
        let deck = [];
        let playerHands = []; // Can be multiple hands due to splitting
        let currentHandIndex = 0;
        let dealerHand = [];
        let gameActive = false;
        let canSurrender = false; // Only allowed on first two cards

        // --- DOM Elements ---
        const dealerCardsDiv = document.getElementById('dealer-cards');
        const dealerScoreDiv = document.getElementById('dealer-score');
        const playerCardsDiv = document.getElementById('player-cards');
        const playerScoreDiv = document.getElementById('player-score');
        const messageDiv = document.getElementById('message');

        const hitButton = document.getElementById('hit-button');
        const standButton = document.getElementById('stand-button');
        const doubleButton = document.getElementById('double-button');
        const splitButton = document.getElementById('split-button');
        const surrenderButton = document.getElementById('surrender-button');
        const newGameButton = document.getElementById('new-game-button');

        // --- Card Data ---
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const values = {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
            'J': 10, 'Q': 10, 'K': 10, 'A': 11
        };

        // --- Core Game Functions ---

        function createDeck() {
            deck = [];
            for (let i = 0; i < 6; i++) { // 6 decks
                for (const suit of suits) {
                    for (const rank of ranks) {
                        deck.push({ rank, suit, value: values[rank] });
                    }
                }
            }
            shuffleDeck();
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function dealCard() {
            if (deck.length < 20) { // Reshuffle if deck is low (penetration point)
                createDeck();
                messageDiv.textContent = "Shuffling a new shoe!";
            }
            return deck.pop();
        }

        function calculateHandValue(hand) {
            let value = 0;
            let numAces = 0;
            for (const card of hand) {
                value += card.value;
                if (card.rank === 'A') {
                    numAces++;
                }
            }
            while (value > 21 && numAces > 0) {
                value -= 10;
                numAces--;
            }
            return value;
        }

        function getHandScoreText(hand) {
            const value = calculateHandValue(hand);
            let text = `${value}`;
            // Check for soft ace only if it's beneficial (value <= 21)
            const hasAce = hand.some(card => card.rank === 'A');
            if (hasAce) {
                let valueWithoutOneAce = 0;
                let acesFound = 0;
                for (const card of hand) {
                    if (card.rank === 'A' && acesFound === 0) {
                        valueWithoutOneAce += 1; // Count first ace as 1
                        acesFound++;
                    } else {
                        valueWithoutOneAce += card.value;
                    }
                }
                if (valueWithoutOneAce + 10 <= 21 && value === valueWithoutOneAce + 10) {
                     text += " (Soft)";
                }
            }
            return text;
        }


        function displayCards(hand, element, hideFirst = false) {
            element.innerHTML = '';
            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.classList.add('card');
                const shouldBeHidden = (index === 0 && hideFirst && gameActive && playerHands.length > 0 && !playerHands[currentHandIndex].stood && !playerHands[currentHandIndex].busted);

                if (shouldBeHidden) {
                    cardDiv.classList.add('hidden');
                    cardDiv.innerHTML = ''; 
                } else {
                    cardDiv.innerHTML = `<div class="rank">${card.rank}</div><div class="suit">${card.suit}</div>`;
                    if (card.suit === '♥' || card.suit === '♦') {
                        cardDiv.classList.add('red');
                    }
                }
                element.appendChild(cardDiv);
            });
        }

        function updateDisplay() {
            if (playerHands.length > 0 && playerHands[currentHandIndex]) {
                const currentHand = playerHands[currentHandIndex];
                displayCards(currentHand.cards, playerCardsDiv);
                playerScoreDiv.textContent = `Score: ${getHandScoreText(currentHand.cards)}`;
                if (playerHands.length > 1) {
                    playerScoreDiv.textContent += ` (Hand ${currentHandIndex + 1}/${playerHands.length})`;
                }
            } else {
                playerCardsDiv.innerHTML = '';
                playerScoreDiv.textContent = '';
            }

            const allPlayerHandsDone = playerHands.every(hand => hand.busted || hand.stood);
            const hideDealerFirstCard = gameActive && !allPlayerHandsDone;
            displayCards(dealerHand, dealerCardsDiv, hideDealerFirstCard);

            if (hideDealerFirstCard) {
                dealerScoreDiv.textContent = `Score: ?`;
                if (dealerHand.length > 0 && dealerHand[0]) { // Ensure dealerHand[0] exists
                    if (dealerHand[0].rank === 'A' && calculateHandValue(dealerHand) !== 21) {
                        // messageDiv.textContent = "Dealer shows an Ace. Insurance?"; // Insurance not implemented
                    } else if (dealerHand[0].value === 10 && calculateHandValue(dealerHand) !== 21) {
                        // messageDiv.textContent = "Dealer shows a 10-value card.";
                    } else {
                        if (gameActive && playerHands.length > 0 && playerHands[currentHandIndex] && !playerHands[currentHandIndex].busted && !playerHands[currentHandIndex].stood) {
                            // messageDiv.textContent = "Your turn."; // This is set by other functions
                        }
                    }
                }
            } else if (dealerHand.length > 0) {
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
            } else {
                dealerScoreDiv.textContent = '';
            }
            
            const currentHand = playerHands[currentHandIndex];
            const isPlayerTurn = gameActive && currentHand && !currentHand.busted && !currentHand.stood;
            const hasInitialTwoCards = currentHand && currentHand.cards.length === 2 && !currentHand.splitFromPair;


            hitButton.disabled = !isPlayerTurn;
            standButton.disabled = !isPlayerTurn;
            doubleButton.disabled = !isPlayerTurn || !hasInitialTwoCards;
            splitButton.disabled = !isPlayerTurn || !hasInitialTwoCards || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4;
            surrenderButton.disabled = !isPlayerTurn || !canSurrender || (currentHand && currentHand.cards.length > 2);
        }

        function resetGame() {
            gameActive = false;
            playerHands = [];
            dealerHand = [];
            currentHandIndex = 0;
            canSurrender = false;
            messageDiv.className = 'message';
            messageDiv.textContent = 'Click "New Game" to start.';
            playerCardsDiv.innerHTML = '';
            dealerCardsDiv.innerHTML = '';
            playerScoreDiv.textContent = '';
            dealerScoreDiv.textContent = '';
            newGameButton.disabled = false;
            disableActionButtons();
            updateDisplay(); // Call to ensure UI is clean
        }

        async function newGame() {
            resetGame(); 
            createDeck(); 
            gameActive = true;
            canSurrender = true; 

            playerHands.push({ cards: [], busted: false, stood: false, doubled: false, splitFromPair: false, surrendered: false });
            dealerHand = [];

            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 
            playerHands[0].cards.push(dealCard());
            dealerHand.push(dealCard()); 

            updateDisplay(); 

            const playerBlackjack = calculateHandValue(playerHands[0].cards) === 21;
            const dealerBlackjack = calculateHandValue(dealerHand) === 21;

            if (dealerBlackjack) {
                displayCards(dealerHand, dealerCardsDiv, false); 
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
                if (playerBlackjack) {
                    messageDiv.textContent = "Push! Both have Blackjack.";
                } else {
                    messageDiv.textContent = "Dealer has Blackjack! You lose.";
                }
                gameActive = false; 
                newGameButton.disabled = false;
                disableActionButtons();
                return;
            }

            if (playerBlackjack) {
                messageDiv.textContent = "Blackjack! You win!";
                gameActive = false; 
                newGameButton.disabled = false;
                disableActionButtons();
                displayCards(dealerHand, dealerCardsDiv, false);
                dealerScoreDiv.textContent = `Score: ${getHandScoreText(dealerHand)}`;
                return;
            }

            messageDiv.textContent = "Your turn. What's your move?";
            updateDisplay(); 
        }

        function disableActionButtons() {
            hitButton.disabled = true;
            standButton.disabled = true;
            doubleButton.disabled = true;
            splitButton.disabled = true;
            surrenderButton.disabled = true;
        }

        async function playerHit() {
            if (!gameActive || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            canSurrender = false; 
            const currentHand = playerHands[currentHandIndex];
            currentHand.cards.push(dealCard());
            
            const handValue = calculateHandValue(currentHand.cards);
            checkAndHighlightMistake('H', currentHand.cards, dealerHand[0]); // Check before updating display for bust/21 message
            updateDisplay(); // Update display after mistake check

            if (handValue > 21) {
                currentHand.busted = true;
                messageDiv.textContent = `Hand ${currentHandIndex + 1} busted! Score: ${handValue}`;
                messageDiv.classList.add('error');
                await nextHandOrDealerTurn();
            } else if (handValue === 21) {
                currentHand.stood = true; 
                // messageDiv.textContent = `Hand ${currentHandIndex + 1} is 21.`; // Message handled by checkAndHighlightMistake or nextHand
                await nextHandOrDealerTurn();
            }
        }

        async function playerStand() {
            if (!gameActive || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;
            
            canSurrender = false;
            const currentHand = playerHands[currentHandIndex];
            currentHand.stood = true;
            checkAndHighlightMistake('S', currentHand.cards, dealerHand[0]);
            // messageDiv.textContent = `Hand ${currentHandIndex + 1} stands.`; // Message handled by checkAndHighlightMistake or nextHand
            updateDisplay();
            await nextHandOrDealerTurn(); 
        }

        async function playerDoubleDown() {
            if (!gameActive || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.splitFromPair) { // Cannot double after split in this version
                messageDiv.textContent = "Can only double down on your first two cards (not after split)!";
                messageDiv.classList.add('error');
                return;
            }
            canSurrender = false;
            
            checkAndHighlightMistake('D', currentHand.cards, dealerHand[0]);
            currentHand.doubled = true;
            currentHand.cards.push(dealCard());
            updateDisplay();

            const handValue = calculateHandValue(currentHand.cards);
            if (handValue > 21) {
                currentHand.busted = true;
                // messageDiv.textContent = `Hand ${currentHandIndex + 1} doubled and busted! Score: ${handValue}`; // Handled by checkAndHighlightMistake
                // messageDiv.classList.add('error');
            } else {
                // messageDiv.textContent = `Hand ${currentHandIndex + 1} doubled. Score: ${handValue}.`; // Handled by checkAndHighlightMistake
            }
            currentHand.stood = true; 
            await nextHandOrDealerTurn();
        }

        async function playerSplit() {
            if (!gameActive || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            canSurrender = false;
            const currentHand = playerHands[currentHandIndex];
            if (currentHand.cards.length !== 2 || currentHand.cards[0].rank !== currentHand.cards[1].rank || playerHands.length >= 4) {
                messageDiv.textContent = "Cannot split this hand!";
                messageDiv.classList.add('error');
                return;
            }
            
            checkAndHighlightMistake('P', currentHand.cards, dealerHand[0]);

            const card1 = currentHand.cards[0];
            const card2 = currentHand.cards[1];

            // Replace current hand with the first split hand
            playerHands[currentHandIndex] = { cards: [card1, dealCard()], busted: false, stood: false, doubled: false, splitFromPair: true, surrendered: false };
            // Insert the second split hand after the current one
            playerHands.splice(currentHandIndex + 1, 0, { cards: [card2, dealCard()], busted: false, stood: false, doubled: false, splitFromPair: true, surrendered: false });
            
            // messageDiv.textContent = "Hand split!"; // Handled by checkAndHighlightMistake
            updateDisplay();

            // Handle Aces - only one card, then stand
            if (card1.rank === 'A') {
                playerHands[currentHandIndex].stood = true;
                if (playerHands[currentHandIndex+1]) playerHands[currentHandIndex+1].stood = true; // Second Ace hand
            }
            
            // If the current (first split) hand is stood (e.g. split Aces), move to next or dealer
            if (playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) {
                 await nextHandOrDealerTurn(); // This will correctly move to the next hand or dealer
            } else {
                updateDisplay(); // Re-update for the new current hand
                // messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`; // Set by nextHandOrDealerTurn or updateDisplay
            }
        }

        async function playerSurrender() {
            if (!gameActive || !canSurrender || !playerHands[currentHandIndex] || playerHands[currentHandIndex].cards.length > 2) {
                 messageDiv.textContent = "Cannot surrender now.";
                 messageDiv.classList.add('error');
                 return;
            }
            
            const currentHand = playerHands[currentHandIndex];
            checkAndHighlightMistake('R', currentHand.cards, dealerHand[0]);
            currentHand.surrendered = true;
            currentHand.stood = true; // Mark as stood to end its turn
            // messageDiv.textContent = "You surrendered Hand " + (currentHandIndex + 1) + "."; // Handled by checkAndHighlightMistake
            // messageDiv.classList.remove('error'); // Surrender is a valid move
            canSurrender = false;
            updateDisplay();
            await nextHandOrDealerTurn(); // Move to next hand or dealer
        }

        async function nextHandOrDealerTurn() {
            let nextHandFound = false;
            // Start searching from the current hand index
            for (let i = currentHandIndex; i < playerHands.length; i++) {
                if (!playerHands[i].busted && !playerHands[i].stood && !playerHands[i].surrendered) {
                    currentHandIndex = i;
                    nextHandFound = true;
                    break;
                }
            }

            if (nextHandFound) {
                updateDisplay();
                messageDiv.textContent = `Now playing Hand ${currentHandIndex + 1}. What's your move?`;
                canSurrender = playerHands[currentHandIndex].cards.length === 2 && !playerHands[currentHandIndex].splitFromPair; // Re-evaluate surrender for new hand
            } else {
                // All player hands are done, or only surrendered hands remain
                await dealerTurn();
            }
        }

        async function dealerTurn() {
            gameActive = false; 
            disableActionButtons(); 
            newGameButton.disabled = true; 

            // Check if all player hands busted or surrendered before dealer plays
            const allPlayerHandsResolved = playerHands.every(hand => hand.busted || hand.surrendered);
            if (allPlayerHandsResolved && playerHands.length > 0) {
                messageDiv.textContent = "All player hands resolved. Dealer's turn skipped.";
                updateDisplay(); // Reveal dealer's hand
                await new Promise(resolve => setTimeout(resolve, 1000));
                resolveGame();
                return;
            }


            messageDiv.textContent = "Dealer's turn...";
            updateDisplay(); // Reveal dealer's hidden card
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            let dealerValue = calculateHandValue(dealerHand);
            // Dealer hits on soft 17 (H17 rule)
            while (dealerValue < 17 || (dealerValue === 17 && dealerHand.some(card => card.rank === 'A' && calculateHandValue(dealerHand.filter(c => c !== card)) + 11 === dealerValue))) {
                if (dealerValue >= 21) break; // Stop if already 21 or bust
                messageDiv.textContent = `Dealer hits (score: ${getHandScoreText(dealerHand)}).`;
                await new Promise(resolve => setTimeout(resolve, 1500)); 
                dealerHand.push(dealCard());
                dealerValue = calculateHandValue(dealerHand);
                updateDisplay();
            }

            await new Promise(resolve => setTimeout(resolve, 1000)); 

            if (dealerValue > 21) {
                messageDiv.textContent = `Dealer busts! (${dealerValue}).`;
            } else {
                messageDiv.textContent = `Dealer stands on ${getHandScoreText(dealerHand)}.`;
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); 

            resolveGame();
        }

        function resolveGame() {
            const dealerValue = calculateHandValue(dealerHand);
            const dealerBusted = dealerValue > 21;
            let finalMessage = "<h3>Game Over</h3>";
            let anyPlayerWon = false;

            playerHands.forEach((hand, index) => {
                const playerValue = calculateHandValue(hand.cards);
                let handResult = `Hand ${index + 1} (${playerValue}): `;
                if (hand.surrendered) {
                    handResult += "Surrendered. You lose half your bet (conceptually).";
                } else if (hand.busted) {
                    handResult += "Busted. You lose.";
                } else if (dealerBusted) {
                    handResult += "Dealer busts. You win!";
                    anyPlayerWon = true;
                } else if (playerValue > dealerValue) {
                    handResult += `You win! (${playerValue} vs Dealer ${dealerValue})`;
                    anyPlayerWon = true;
                } else if (playerValue < dealerValue) {
                    handResult += `You lose. (${playerValue} vs Dealer ${dealerValue})`;
                } else { // Push
                    handResult += `Push. (${playerValue} vs Dealer ${dealerValue})`;
                    anyPlayerWon = true; // A push is not a loss
                }
                finalMessage += `<p>${handResult}</p>`;
            });
            
            messageDiv.innerHTML = finalMessage;
            messageDiv.className = 'message'; // Reset class
            if (!anyPlayerWon && playerHands.every(h => h.busted || h.surrendered || calculateHandValue(h.cards) < dealerValue && !dealerBusted)) {
                 // If no hand won or pushed, and dealer didn't bust (unless all player hands busted first)
                 // messageDiv.classList.add('error'); // Optional: make it red if all hands lost
            }


            newGameButton.disabled = false; 
            disableActionButtons(); 
            updateDisplay(); // Final display update
        }

        // --- Basic Strategy Logic (H17, DAS - Double After Split allowed, Surrender allowed) ---
        // Note: This JS implementation of BS might vary slightly from complex charts.
        // R/H means Surrender if available, else Hit. D/S means Double if allowed, else Stand. D/H means Double if allowed, else Hit.
        // P/H means Split if allowed, else Hit.
        function getOptimalPlay(playerHandCards, dealerUpCard, canSplit, canDouble, canSurrenderNow) {
            const playerValue = calculateHandValue(playerHandCards);
            const dealerCardValue = dealerUpCard.value; // Numeric value (A=11 initially)
            const dealerIsAce = dealerUpCard.rank === 'A';
            const dealerIsTen = dealerCardValue === 10;

            const isPlayerPair = playerHandCards.length === 2 && playerHandCards[0].rank === playerHandCards[1].rank;
            let isPlayerSoft = false;
            if (playerHandCards.some(c => c.rank === 'A')) {
                let nonAceTotal = 0;
                let aceCount = 0;
                playerHandCards.forEach(c => {
                    if (c.rank === 'A') aceCount++; else nonAceTotal += c.value;
                });
                if (aceCount > 0 && nonAceTotal + 11 + (aceCount - 1) === playerValue && playerValue <= 21) {
                    isPlayerSoft = true;
                }
            }
            
            // 0. Surrender (if available on first two cards)
            if (canSurrenderNow && playerHandCards.length === 2) {
                if (!isPlayerPair) { // Surrender rules for hard totals (not pairs)
                    if (playerValue === 16 && (dealerUpCard.rank === '9' || dealerIsTen || dealerIsAce)) return 'R';
                    if (playerValue === 15 && dealerIsTen) return 'R';
                }
                // Some strategies might surrender 8,8 vs A, but splitting is generally better.
            }

            // 1. Pairs (if canSplit)
            if (isPlayerPair && canSplit) {
                const pRank = playerHandCards[0].rank;
                if (pRank === 'A') return 'P';
                if (pRank === '10' || pRank === 'J' || pRank === 'Q' || pRank === 'K') return 'S'; // Never split 10s
                if (pRank === '9') {
                    if (dealerCardValue === 7 || dealerIsTen || dealerIsAce) return 'S';
                    return 'P';
                }
                if (pRank === '8') return 'P'; // Always split 8s
                if (pRank === '7') return (dealerCardValue <= 7) ? 'P' : 'H';
                if (pRank === '6') return (dealerCardValue <= 6) ? 'P' : 'H'; // Some charts say P/H vs 2
                if (pRank === '5') return (dealerCardValue <= 9) ? 'D' : 'H'; // Treat as Hard 10
                if (pRank === '4') { // 4,4
                    if (dealerCardValue === 5 || dealerCardValue === 6) return 'P'; // P/H if DAS
                    return 'H';
                }
                if (pRank === '3' || pRank === '2') {
                    if (dealerCardValue <= 7) return 'P'; // P/H for 2,3 vs 2,3 if DAS
                    return 'H';
                }
            }

            // 2. Soft Totals
            if (isPlayerSoft) {
                if (playerValue >= 20) return 'S'; // A,9 (S20) or A,A,8 (S20)
                if (playerValue === 19) { // A,8 (S19)
                     return (dealerCardValue === 6 && canDouble) ? 'D' : 'S'; // D/S
                }
                if (playerValue === 18) { // A,7 (S18)
                    if (canDouble && dealerCardValue >= 2 && dealerCardValue <= 6) return 'D'; // D/S
                    if (dealerCardValue <= 8) return 'S';
                    return 'H';
                }
                if (playerValue === 17) { // A,6 (S17)
                    if (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 16 || playerValue === 15) { // A,5 or A,4
                    if (canDouble && dealerCardValue >= 4 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                if (playerValue === 14 || playerValue === 13) { // A,3 or A,2
                    if (canDouble && dealerCardValue >= 5 && dealerCardValue <= 6) return 'D';
                    return 'H';
                }
                return 'H'; // Should not be reached for soft totals like A,A (S12) as it's a pair
            }

            // 3. Hard Totals
            if (playerValue >= 17) return 'S';
            if (playerValue === 16) return (dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 15) return (dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 14) return (dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 13) return (dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 12) return (dealerCardValue >= 4 && dealerCardValue <= 6) ? 'S' : 'H';
            if (playerValue === 11) return canDouble ? 'D' : 'H';
            if (playerValue === 10) return (canDouble && dealerCardValue <= 9) ? 'D' : 'H';
            if (playerValue === 9) return (canDouble && dealerCardValue >= 3 && dealerCardValue <= 6) ? 'D' : 'H';
            if (playerValue <= 8) return 'H';

            return 'H'; // Fallback
        }


        function checkAndHighlightMistake(playerAction, playerHandCards, dealerUpCard) {
            if (!gameActive || !playerHands[currentHandIndex] || playerHands[currentHandIndex].stood || playerHands[currentHandIndex].busted) return;

            const currentFullHand = playerHands[currentHandIndex];
            // If hand is already stood or busted (e.g. from split aces), no mistake check
            if (currentFullHand.stood || currentFullHand.busted) return;

            const actualCanSurrender = canSurrender && playerHandCards.length === 2 && !currentFullHand.splitFromPair;
            const actualCanDouble = playerHandCards.length === 2 && !currentFullHand.splitFromPair; // DAS is generally allowed, but this trainer simplifies to no double after split.
            const actualCanSplit = playerHandCards.length === 2 && playerHandCards[0].rank === playerHandCards[1].rank && playerHands.length < 4;

            let optimalPlayCode = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, actualCanDouble, actualCanSurrender);
            
            // Adjust optimal play if the "best" action isn't practically available
            // Example: Optimal is 'D', but player can't double (e.g. already hit, or not enough funds in real game)
            // For this trainer, we assume funds are infinite, so only game rules (like no double after hit) apply.
            if (optimalPlayCode === 'D' && !actualCanDouble) {
                // If double is suggested but not allowed (e.g. after a hit, or not initial 2 cards)
                // Re-evaluate as Hit or Stand based on hard/soft totals without doubling.
                // This requires a "secondary" optimal play. For simplicity, if D not allowed, often H is next best for low totals.
                // Or S for higher totals. This part can get complex.
                // For now, if D is suggested by getOptimalPlay but actualCanDouble is false (e.g. after a hit),
                // we need to find the non-double alternative.
                // Let's re-run getOptimalPlay with canDouble = false.
                optimalPlayCode = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, false, false); // No surrender after first action
            }
            if (optimalPlayCode === 'P' && !actualCanSplit) {
                // If split is suggested but not allowed (e.g. max hands reached, or not a pair)
                // Re-evaluate as a hard/soft total.
                optimalPlayCode = getOptimalPlay(playerHandCards, dealerUpCard, false, actualCanDouble, false);
            }
             if (optimalPlayCode === 'R' && !actualCanSurrender) {
                // If surrender is suggested but not allowed (e.g. after a hit)
                optimalPlayCode = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, actualCanDouble, false);
            }


            // Handle compound actions from strategy chart like D/S, R/H
            let optimalActionText = mapActionCodeToText(optimalPlayCode);
            let chosenActionText = mapActionCodeToText(playerAction);
            let isMistake = false;

            if (optimalPlayCode.includes('/')) { // e.g., "D/S", "R/H"
                const primaryAction = optimalPlayCode.split('/')[0];
                const secondaryAction = optimalPlayCode.split('/')[1];
                if (playerAction === primaryAction) {
                    // Correct if primary action taken (e.g., D in D/S)
                    // Need to check if primary action was possible
                    if (primaryAction === 'D' && !actualCanDouble) isMistake = true; // Tried to double but couldn't
                    else if (primaryAction === 'P' && !actualCanSplit) isMistake = true;
                    else if (primaryAction === 'R' && !actualCanSurrender) isMistake = true;
                    else isMistake = false;
                } else if (playerAction === secondaryAction) {
                    // Correct if secondary action taken AND primary was NOT possible or not chosen
                    if (primaryAction === 'D' && actualCanDouble) isMistake = true; // Should have doubled
                    else if (primaryAction === 'P' && actualCanSplit) isMistake = true; // Should have split
                    else if (primaryAction === 'R' && actualCanSurrender) isMistake = true; // Should have surrendered
                    else isMistake = false;
                } else {
                    isMistake = true; // Chose something else entirely
                }
                optimalActionText = `${mapActionCodeToText(primaryAction)} (or ${mapActionCodeToText(secondaryAction)} if ${primaryAction} not allowed/preferred)`;
            } else {
                if (playerAction !== optimalPlayCode) {
                    isMistake = true;
                }
            }
            
            // Final check: if optimal was D, P, R but not available, and player chose H/S correctly based on that.
            if (isMistake) {
                 // If the optimal play was D, P, or R, but it wasn't available,
                 // and the player made the correct H or S move instead, it's not a mistake.
                 if (optimalPlayCode === 'D' && !actualCanDouble && (playerAction === 'H' || playerAction === 'S')) {
                     const fallbackOptimal = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, false, false);
                     if (playerAction === fallbackOptimal) isMistake = false;
                 } else if (optimalPlayCode === 'P' && !actualCanSplit && (playerAction === 'H' || playerAction === 'S' || playerAction === 'D')) {
                     const fallbackOptimal = getOptimalPlay(playerHandCards, dealerUpCard, false, actualCanDouble, false);
                     if (playerAction === fallbackOptimal) isMistake = false;
                 } else if (optimalPlayCode === 'R' && !actualCanSurrender && (playerAction === 'H' || playerAction === 'S')) {
                      const fallbackOptimal = getOptimalPlay(playerHandCards, dealerUpCard, actualCanSplit, actualCanDouble, false);
                     if (playerAction === fallbackOptimal) isMistake = false;
                 }
            }


            if (isMistake) {
                messageDiv.textContent = `Mistake! You chose ${chosenActionText}. Optimal: ${optimalActionText}.`;
                messageDiv.classList.add('error');
            } else {
                messageDiv.textContent = `Correct! You chose ${chosenActionText}. (Optimal: ${optimalActionText})`;
                messageDiv.classList.remove('error');
                messageDiv.classList.add('message');
            }
        }

        function mapActionCodeToText(code) {
            if (!code) return "Unknown";
            if (code.includes('/')) { // Handle compound like "D/S"
                const parts = code.split('/');
                return `${mapActionCodeToText(parts[0])} or ${mapActionCodeToText(parts[1])}`;
            }
            switch (code) {
                case 'H': return 'Hit';
                case 'S': return 'Stand';
                case 'D': return 'Double Down';
                case 'P': return 'Split';
                case 'R': return 'Surrender';
                default: return `Unknown (${code})`;
            }
        }

        // --- Tab Functionality for Strategy Guide ---
        const tabButtons = document.querySelectorAll('#strategy-guide-container .tab-button');
        const tabContents = document.querySelectorAll('#strategy-guide-container .tab-content');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const tabId = button.dataset.tab;
                const targetTabContent = document.getElementById(tabId + '-tab');
                if (targetTabContent) {
                    targetTabContent.classList.add('active');
                }
            });
        });

        // --- Event Listeners ---
        newGameButton.addEventListener('click', newGame);
        hitButton.addEventListener('click', playerHit);
        standButton.addEventListener('click', playerStand);
        doubleButton.addEventListener('click', playerDoubleDown);
        splitButton.addEventListener('click', playerSplit);
        surrenderButton.addEventListener('click', playerSurrender);

        // Initial setup
        resetGame();
    </script>
</body>
</html>
